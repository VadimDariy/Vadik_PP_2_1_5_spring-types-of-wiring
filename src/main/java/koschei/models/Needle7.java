package koschei.models;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class Needle7 { // Иголка
    private final Deth8 deth;
    @Autowired
    public Needle7(Deth8 deth){
        this.deth = deth;
    }

    @Override
    public String toString() {
        return ", смерть Кощея на игле :( " + deth.toString();
    }
}
/*  Класс "Death8" помечен аннотацией "@Component", поэтому "Spring" будет интерпритировать этот класс как компонент,
    контейнера приложения Spring, в котором автоматически будет создавать объекты этого класса и управлять ими.

    1.Кагда Spring видет аннотацию @Autowired над конструктором "Needle7(Deth8 deth)", то "Spring" понимает, что ему
      нужно внедрить зависьмость от класса "Deth8" именно в этот конструктор "Needle7(Deth8 deth)", тем самым мы через
      этот конструктор инициализируем переменную "deth" значением "Прощай Кощей!"

   2. Далее переопределяем метод "toString()" в теле которго будет выполняться конкатенация строк:
          return ", смерть Кощея на игле :( " + deth.toString();
      В ней мы объединяем две строки:
          - первая эта строка, которую прописывает программист вручную: ", смерть Кощея на игле :( "
          - вторая это строка, которая представляет результат работы метода "deth.toString()" = "Прощай Кощей!"
      В итоге метод "toString()" будет уже возвращать готовый кусок выражения: ", смерть Кощея на игле :( Прощай Кощей!"

    3. Далее Spring создаёт экземпляр этого класса в виде строкого представления, который содержит в себе строку
       ", смерть Кощея на игле :( Прощай Кощей!" и использует его как зависимость, для внедрения в класс "Egg6", что бы
       инициализировать переменную needle = ", смерть Кощея на игле :( Прощай Кощей!"*/