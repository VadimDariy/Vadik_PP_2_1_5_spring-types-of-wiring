package koschei.models;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class Egg6 { // Яйцо
private final Needle7 needle;

@Autowired
public Egg6 (Needle7 needle) {
    this.needle = needle;
}

    @Override
    public String toString() {
        return ", в яйце иголка " + needle.toString();
    }
}

/*  Класс "Egg6" помечен аннотацией "@Component", поэтому "Spring" будет интерпритировать этот класс как компонент,
    контейнера приложения Spring, в котором автоматически будет создавать объекты этого класса и управлять ими.

    1.Кагда Spring видет аннотацию @Autowired над конструктором "Egg6 (Needle7 needle)", то "Spring" понимает, что ему
      нужно внедрить зависьмость от класса "Needle" именно в этот конструктор "Egg6 (Needle7 needle)", тем самым мы через
      этот конструктор инициализируем переменную "needle" значением ", смерть Кощея на игле :( Прощай Кощей!"

   2. Далее переопределяем метод "toString()" в теле которго будет выполняться конкатенация строк:
          return ", смерть Кощея на игле :( " + needle.toString();
      В ней мы объединяем две строки:
          - первая эта строка, которую прописывает программист вручную: ", в яйце иголка "
          - вторая это строка, которая представляет результат работы метода "needle.toString()" =
           ", смерть Кощея на игле :( Прощай Кощей!""
      Т.е. метод "toString()" будет уже возвращать готовый кусок выражения:
           ", в яйце иголка, смерть Кощея на игле :( Прощай Кощей!"

    3. Далее Spring создаёт экземпляр класса "Egg6" в виде строкого представления, который содержит в себе строку
      ", в яйце иголка, смерть Кощея на игле :( Прощай Кощей!" и использует его как зависимость, для внедрения в класс
      "Duck5".*/